defmodule Nexus.Treasury.ReconciliationTest do
  use Cabbage.Feature, async: false, file: "treasury/reconciliation.feature"
  use Nexus.DataCase

  @moduletag :feature
  @moduletag :no_sandbox

  alias Nexus.App
  alias Nexus.Repo
  alias Nexus.ERP.Commands.IngestInvoice
  alias Nexus.ERP.Commands.UploadStatement
  alias Nexus.Treasury.Projections.Reconciliation
  alias Nexus.Treasury.ProcessManagers.ReconciliationManager

  setup do
    org_id = Nexus.Schema.generate_uuidv7()

    Ecto.Adapters.SQL.Sandbox.unboxed_run(Nexus.Repo, fn ->
      Nexus.Repo.delete_all(Reconciliation)
      Nexus.Repo.delete_all(Nexus.ERP.Projections.StatementLine)
      Nexus.Repo.delete_all(Nexus.ERP.Projections.Statement)
      Nexus.Repo.delete_all(Nexus.ERP.Projections.Invoice)
      Ecto.Adapters.SQL.query!(Nexus.Repo, "DELETE FROM projection_versions")
    end)

    # Use a shared state atom to avoid PID-based stream clashes if any
    {:ok, %{org_id: org_id, pm_stream: "Treasury.ReconciliationManager-#{org_id}"}}
  end

  # --- Given ---

  defgiven ~r/^the following invoices exist:$/, %{table: table}, state do
    # Map Gherkin names to UUIDs for DB compatibility
    mapping =
      Enum.reduce(table, %{}, fn row, acc ->
        uuid = Nexus.Schema.generate_uuidv7()
        Map.put(acc, row.invoice_id, uuid)
      end)

    Enum.each(table, fn row ->
      invoice_id = Map.get(mapping, row.invoice_id)

      command = %IngestInvoice{
        org_id: state.org_id,
        invoice_id: invoice_id,
        entity_id: "ENT-#{row.invoice_id}",
        currency: row.currency,
        amount: row.amount,
        subsidiary: "Default",
        line_items: [%{description: "Test", amount: row.amount}],
        sap_document_number: "SAP-#{row.invoice_id}",
        sap_status: "Verified"
      }

      assert :ok = App.dispatch(command)

      {:ok, [%{data: event, event_number: num}]} =
        Nexus.EventStore.read_stream_forward(invoice_id)

      project_event(event, num, "ERP.InvoiceProjector", Nexus.ERP.Projectors.InvoiceProjector)
      sync_reconciliation_manager(event, num, state)
    end)

    {:ok, Map.put(state, :invoice_mapping, mapping)}
  end

  defgiven ~r/^the following statement lines exist:$/, %{table: table}, state do
    statement_id = Nexus.Schema.generate_uuidv7()

    mapping =
      Enum.reduce(table, %{}, fn row, acc ->
        # We don't control the UUID generated by the aggregate for lines,
        # but we need to track the mapping for assertions.
        # Actually, the aggregate generates them. We'll find them after projection.
        acc
      end)

    # date,ref,amount,currency,narrative
    csv_rows =
      Enum.map(table, fn row ->
        "2024-02-25,REF-#{row.statement_line_id},#{row.amount},#{row.currency},Test matching"
      end)

    csv_content = "date,ref,amount,currency,narrative\n" <> Enum.join(csv_rows, "\n")

    command = %UploadStatement{
      org_id: state.org_id,
      statement_id: statement_id,
      filename: "test.csv",
      format: "csv",
      raw_content: csv_content
    }

    assert :ok = App.dispatch(command)

    {:ok, [%{data: event, event_number: num}]} =
      Nexus.EventStore.read_stream_forward(statement_id)

    project_event(event, num, "ERP.StatementProjector", Nexus.ERP.Projectors.StatementProjector)
    sync_reconciliation_manager(event, num, state)

    # Re-map line IDs based on references to support Then steps
    line_mapping =
      Ecto.Adapters.SQL.Sandbox.unboxed_run(Nexus.Repo, fn ->
        import Ecto.Query

        Repo.all(
          from l in Nexus.ERP.Projections.StatementLine, where: l.statement_id == ^statement_id
        )
        |> Enum.into(%{}, fn l -> {String.replace(l.ref, "REF-", ""), l.id} end)
      end)

    {:ok, Map.merge(state, %{statement_id: statement_id, line_mapping: line_mapping})}
  end

  defgiven ~r/^an invoice "(?<id>[^"]+)" is ingested for (?<amount>[^ ]+) (?<currency>.+)$/,
           %{id: invoice_id_alias, amount: amount, currency: currency},
           state do
    invoice_id = Nexus.Schema.generate_uuidv7()

    command = %IngestInvoice{
      org_id: state.org_id,
      invoice_id: invoice_id,
      entity_id: "ENT-#{invoice_id_alias}",
      currency: currency,
      amount: amount,
      subsidiary: "Default",
      line_items: [%{description: "Test", amount: amount}],
      sap_document_number: "SAP-#{invoice_id_alias}",
      sap_status: "Verified"
    }

    assert :ok = App.dispatch(command)
    {:ok, [%{data: event, event_number: num}]} = Nexus.EventStore.read_stream_forward(invoice_id)
    project_event(event, num, "ERP.InvoiceProjector", Nexus.ERP.Projectors.InvoiceProjector)
    sync_reconciliation_manager(event, num, state)

    mapping = Map.get(state, :invoice_mapping, %{}) |> Map.put(invoice_id_alias, invoice_id)
    {:ok, Map.put(state, :invoice_mapping, mapping)}
  end

  # --- When ---

  defwhen ~r/^the matching engine runs$/, _vars, state do
    # In the manual pattern, the engine runs *during* sync_reconciliation_manager.
    # So this step is a no-op or just verification.
    {:ok, state}
  end

  defwhen ~r/^a statement line "(?<id>[^"]+)" is uploaded for (?<amount>[^ ]+) (?<currency>.+)$/,
          %{id: line_id_alias, amount: amount, currency: currency},
          state do
    statement_id = Nexus.Schema.generate_uuidv7()

    # date,ref,amount,currency,narrative
    csv_content = """
    date,ref,amount,currency,narrative
    2024-02-25,REF-#{line_id_alias},#{amount},#{currency},Manual upload test
    """

    command = %UploadStatement{
      org_id: state.org_id,
      statement_id: statement_id,
      filename: "test.csv",
      format: "csv",
      raw_content: csv_content
    }

    assert :ok = App.dispatch(command)

    {:ok, [%{data: event, event_number: num}]} =
      Nexus.EventStore.read_stream_forward(statement_id)

    project_event(event, num, "ERP.StatementProjector", Nexus.ERP.Projectors.StatementProjector)
    sync_reconciliation_manager(event, num, state)

    # Update line mapping
    new_lines =
      Ecto.Adapters.SQL.Sandbox.unboxed_run(Nexus.Repo, fn ->
        import Ecto.Query

        Repo.all(
          from l in Nexus.ERP.Projections.StatementLine, where: l.statement_id == ^statement_id
        )
        |> Enum.into(%{}, fn l -> {String.replace(l.ref, "REF-", ""), l.id} end)
      end)

    line_mapping = Map.get(state, :line_mapping, %{}) |> Map.merge(new_lines)
    {:ok, Map.put(state, :line_mapping, line_mapping)}
  end

  # --- Then ---

  defthen ~r/^the invoice "(?<inv_id_alias>[^"]+)" and statement line "(?<line_id_alias>[^"]+)" should be reconciled$/,
          %{inv_id_alias: inv_id_alias, line_id_alias: line_id_alias},
          state do
    inv_id = Map.get(state.invoice_mapping, inv_id_alias)
    line_id = Map.get(state.line_mapping, line_id_alias)

    recon = get_reconciliation_by_invoice(inv_id)
    assert recon != nil, "Expected reconciliation record for invoice #{inv_id_alias} (#{inv_id})"
    assert recon.status == :matched
    assert recon.statement_line_id == line_id
    {:ok, state}
  end

  defthen ~r/^a settlement unmatched exception should be recorded for "(?<line_id_alias>[^"]+)"$/,
          %{line_id_alias: line_id_alias},
          state do
    line_id = Map.get(state.line_mapping, line_id_alias)
    line = get_statement_line(line_id)
    assert line != nil, "Statement line #{line_id_alias} not found"
    recon = get_reconciliation_by_statement_line(line_id)
    assert recon == nil
    {:ok, state}
  end

  defthen ~r/^the process manager should dispatch a ReconcileTransaction command for "(?<inv_id_alias>[^"]+)"$/,
          %{inv_id_alias: inv_id_alias},
          state do
    inv_id = Map.get(state.invoice_mapping, inv_id_alias)
    recon = get_reconciliation_by_invoice(inv_id)
    assert recon != nil
    assert recon.status == :matched
    {:ok, state}
  end

  # --- Helpers ---

  defp project_event(event, event_number, handler_name, projector_module) do
    metadata = %{
      handler_name: handler_name,
      event_number: event_number
    }

    Ecto.Adapters.SQL.Sandbox.unboxed_run(Nexus.Repo, fn ->
      projector_module.handle(event, metadata)
    end)
  end

  defp sync_reconciliation_manager(event, event_number, state) do
    # 1. Fetch current PM state by replaying its virtual stream
    pm_state =
      case Nexus.EventStore.read_stream_forward(state.pm_stream) do
        {:ok, events} ->
          Enum.reduce(events, %ReconciliationManager{}, fn %{data: e}, acc ->
            ReconciliationManager.apply(acc, e)
          end)

        {:error, :stream_not_found} ->
          %ReconciliationManager{}
      end

    # 2. Call handle/2
    case ReconciliationManager.handle(pm_state, event) do
      [] ->
        :ok

      command when is_struct(command) ->
        dispatch_and_project_recon(command)

      commands when is_list(commands) ->
        Enum.each(commands, &dispatch_and_project_recon/1)
    end

    # 3. Update and persist PM state (simulating Commanded)
    new_pm_state = ReconciliationManager.apply(pm_state, event)

    event_data = %EventStore.EventData{
      event_type: to_string(event.__struct__),
      data: event,
      metadata: %{}
    }

    :ok = Nexus.EventStore.append_to_stream(state.pm_stream, :any_version, [event_data])
  end

  defp dispatch_and_project_recon(command) do
    assert :ok = App.dispatch(command)
    recon_id = command.reconciliation_id
    {:ok, [%{data: event, event_number: num}]} = Nexus.EventStore.read_stream_forward(recon_id)

    project_event(
      event,
      num,
      "Treasury.ReconciliationProjector",
      Nexus.Treasury.Projectors.ReconciliationProjector
    )
  end

  defp get_reconciliation_by_invoice(invoice_id) do
    Ecto.Adapters.SQL.Sandbox.unboxed_run(Nexus.Repo, fn ->
      import Ecto.Query
      Repo.one(from r in Reconciliation, where: r.invoice_id == ^invoice_id)
    end)
  end

  defp get_reconciliation_by_statement_line(line_id) do
    Ecto.Adapters.SQL.Sandbox.unboxed_run(Nexus.Repo, fn ->
      import Ecto.Query
      Repo.one(from r in Reconciliation, where: r.statement_line_id == ^line_id)
    end)
  end

  defp get_statement_line(line_id) do
    Ecto.Adapters.SQL.Sandbox.unboxed_run(Nexus.Repo, fn ->
      import Ecto.Query
      Repo.one(from l in Nexus.ERP.Projections.StatementLine, where: l.id == ^line_id)
    end)
  end
end
